# Based on code by Jason_Steven
# http://forum.worldwindcentral.com/showthread.php?p=69704

# R implementation by Robert Hijmans
# April 2010
# version 1
# license GPL3


if (!isGeneric("areaPolygon")) {
	setGeneric("areaPolygon", function(x, ...)
		standardGeneric("areaPolygon"))
}	

setMethod('areaPolygon', signature(x='data.frame'), 
	function(x, r=6378137, ...) {
		areaPolygon(as.matrix(x), r=r, ...)
} )


setMethod('areaPolygon', signature(x='SpatialPolygons'), 
function(x, r=6378137, ...) {
	p = xy@polygons
	n = length(p)
	res = vector(length=n)
	for (i in 1:n) {
		parts = length( p[[i]]@Polygons )
		sumarea = 0
		for (j in 1:parts) {
			crd = p[[i]]@Polygons[[j]]@coords
			ar = areaPolygon(crd, r=r, ...)
			if (p[[i]]@Polygons[[j]]@hole) {
				sumarea = sumarea - ar
			} else {
				sumarea = sumarea + ar
			}
		}
		res[i] = sumarea
	}
	return(res)
} )



setMethod('areaPolygon', signature(x='matrix'), 
function(x, r=6378137, ...) {

	haversine <- function(y) { (1-cos(y))/2 }

	x <- .pointsToMatrix(x) * pi / 180 
	.isPolygon(x)
	
	r <- r[1]

	j <- 1:nrow(xy)
	k <- c(2:nrow(xy), 1)
	lam1 <- x[j,1]
	lam2 <- x[k,1]
	i <- ! lam1 == lam2
	j <- j[i]
	k <- k[i]
	lam1 <- x[j,1]
	lam2 <- x[k,1]
	beta1 <- x[j,2]
	beta2 <- x[k,2]
	cosB1 <- cos( beta1 )
	cosB2 <- cos( beta2 )

	hav <- haversine( beta2 - beta1 ) + cosB1 * cosB2 * haversine( lam2 - lam1 )
	a <- 2 * asin( sqrt( hav ) )
	b <- pi / 2 - beta2
	c <- pi / 2 - beta1
	s <- 0.5 * ( a + b + c )
	t <- tan( s / 2 ) * tan( ( s - a ) / 2 ) *  tan( ( s - b ) / 2 ) * tan( ( s - c ) / 2 )
	
	excess <- abs( 4 * atan( sqrt( abs( t ) ) ) )
	excess[lam2 < lam1] <- -excess[lam2 < lam1]
	
	arsum <- abs( sum( excess ) ) * r * r
    return(arsum )
} )



